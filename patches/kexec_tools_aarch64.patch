diff --git a/configure.ac b/configure.ac
index 8b69d3d..e33d0e5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -30,6 +30,9 @@ case $target_cpu in
 	powerpc64 )
 		ARCH="ppc64"
 		;;
+	aarch64* )
+		ARCH="arm64"
+		;;
 	arm* )
 		ARCH="arm"
 		;;
diff --git a/include/elf.h b/include/elf.h
index c958a40..b803de7 100644
--- a/include/elf.h
+++ b/include/elf.h
@@ -259,6 +259,7 @@ typedef struct
 #define EM_ARC_A5	93		/* ARC Cores Tangent-A5 */
 #define EM_XTENSA	94		/* Tensilica Xtensa Architecture */
 #define EM_NUM		95
+#define EM_AARCH64	183		/* ARMv8-A */
 
 /* If it is necessary to assign new unofficial EM_* values, please
    pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
diff --git a/kexec/Makefile b/kexec/Makefile
index 77f37ae..904c127 100644
--- a/kexec/Makefile
+++ b/kexec/Makefile
@@ -50,8 +50,13 @@ KEXEC_SRCS += $($(ARCH)_ARCH_REUSE_INITRD)
 $(ARCH)_ARCH_INIT		= kexec/arch_init.c
 KEXEC_SRCS += $($(ARCH)_ARCH_INIT)
 
+dist				+= kexec/dt-ops.c kexec/dt-ops.h
+$(ARCH)_DT_OPS		=
+KEXEC_SRCS			+= $($(ARCH)_DT_OPS)
+
 include $(srcdir)/kexec/arch/alpha/Makefile
 include $(srcdir)/kexec/arch/arm/Makefile
+include $(srcdir)/kexec/arch/arm64/Makefile
 include $(srcdir)/kexec/arch/i386/Makefile
 include $(srcdir)/kexec/arch/ia64/Makefile
 include $(srcdir)/kexec/arch/mips/Makefile
diff --git a/kexec/arch/arm64/Makefile b/kexec/arch/arm64/Makefile
new file mode 100644
index 0000000..37414dc
--- /dev/null
+++ b/kexec/arch/arm64/Makefile
@@ -0,0 +1,40 @@
+
+arm64_FS2DT += kexec/fs2dt.c
+arm64_FS2DT_INCLUDE += -include $(srcdir)/kexec/arch/arm64/kexec-arm64.h \
+	-include $(srcdir)/kexec/arch/arm64/crashdump-arm64.h
+
+arm64_DT_OPS += kexec/dt-ops.c
+
+arm64_CPPFLAGS += -I $(srcdir)/kexec/
+
+arm64_KEXEC_SRCS += \
+	kexec/arch/arm64/kexec-arm64.c \
+	kexec/arch/arm64/kexec-image-arm64.c \
+	kexec/arch/arm64/kexec-elf-arm64.c \
+	kexec/arch/arm64/crashdump-arm64.c
+
+arm64_ARCH_REUSE_INITRD =
+arm64_ADD_SEGMENT =
+arm64_VIRT_TO_PHYS =
+arm64_PHYS_TO_VIRT =
+
+dist += $(arm64_KEXEC_SRCS) \
+	kexec/arch/arm64/Makefile \
+	kexec/arch/arm64/kexec-arm64.h \
+	kexec/arch/arm64/crashdump-arm64.h
+
+ifdef HAVE_LIBFDT
+
+LIBS += -lfdt
+
+else
+
+include $(srcdir)/kexec/libfdt/Makefile.libfdt
+
+libfdt_SRCS += $(LIBFDT_SRCS:%=kexec/libfdt/%)
+
+arm64_CPPFLAGS += -I$(srcdir)/kexec/libfdt
+
+arm64_KEXEC_SRCS += $(libfdt_SRCS)
+
+endif
diff --git a/kexec/arch/arm64/crashdump-arm64.c b/kexec/arch/arm64/crashdump-arm64.c
new file mode 100644
index 0000000..a929b9e
--- /dev/null
+++ b/kexec/arch/arm64/crashdump-arm64.c
@@ -0,0 +1,310 @@
+/*
+ * crashdump for arm64
+ *
+ * Copyright (C) Nokia Corporation, 2010.
+ * Author: Mika Westerberg
+ *
+ * Based on x86 implementation
+ * Copyright (C) IBM Corporation, 2005. All rights reserved
+ *
+ * Copyright (c) 2014 Linaro Limited
+ * Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define _GNU_SOURCE /* for asprintf */
+
+#include <assert.h>
+#include <elf.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "kexec.h"
+#include "crashdump.h"
+#include "crashdump-arm64.h"
+#include "kexec-arm64.h"
+#include "kexec-elf.h"
+
+
+/*
+ * Used to save various memory ranges/regions needed for the captured
+ * kernel to boot. (like memmap= option in other archs)
+ */
+static struct memory_range crash_memory_ranges[CRASH_MAX_MEMORY_RANGES];
+struct memory_ranges crashmem_rgns = {
+	.size = 0,
+	.ranges = crash_memory_ranges,
+};
+
+/* memory range reserved for crashkernel */
+struct memory_range crash_reserved_mem;
+struct memory_ranges usablemem_rgns = {
+	.size = 0,
+	.ranges = &crash_reserved_mem,
+};
+
+static struct crash_elf_info elf_info = {
+	.class		= ELFCLASS64,
+#if (__BYTE_ORDER == __LITTLE_ENDIAN)
+	.data		= ELFDATA2LSB,
+#else
+	.data		= ELFDATA2MSB,
+#endif
+	.machine	= EM_AARCH64,
+};
+
+int is_crashkernel_mem_reserved(void)
+{
+	uint64_t start, end;
+
+	if (parse_iomem_single("Crash kernel\n", &start, &end) == 0)
+		return start != end;
+
+	return 0;
+}
+
+/*
+ * crash_range_callback() - callback called for each iomem region
+ * @data: not used
+ * @nr: not used
+ * @str: name of the memory region
+ * @base: start address of the memory region
+ * @length: size of the memory region
+ *
+ * This function is called once for each memory region found in /proc/iomem.
+ * It locates system RAM and crashkernel reserved memory and places these to
+ * variables: @crash_memory_ranges and @crash_reserved_mem. Number of memory
+ * regions is placed in @crash_memory_nr_ranges.
+ */
+
+static int crash_range_callback(void *UNUSED(data), int UNUSED(nr),
+				char *str, unsigned long long base,
+				unsigned long long length)
+{
+	struct memory_range *range;
+
+	assert(arm64_mem.memstart);
+
+	if (crashmem_rgns.size >= CRASH_MAX_MEMORY_RANGES)
+		return 1;
+
+	range = crashmem_rgns.ranges + crashmem_rgns.size;
+
+	if (strncmp(str, "System RAM\n", 11) == 0) {
+		range->start = base;
+		range->end = base + length - 1;
+		range->type = RANGE_RAM;
+		crashmem_rgns.size++;
+	} else if (strncmp(str, "Crash kernel\n", 13) == 0) {
+		if (base < arm64_mem.memstart)
+			base += arm64_mem.memstart;
+		crash_reserved_mem.start = base;
+		crash_reserved_mem.end = base + length - 1;
+		crash_reserved_mem.type = RANGE_RAM;
+		usablemem_rgns.size++;
+	}
+
+	return 0;
+}
+
+/*
+ * crash_exclude_range() - excludes memory region reserved for crashkernel
+ *
+ * Function locates where crashkernel reserved memory is and removes that
+ * region from the available memory regions.
+ */
+static void crash_exclude_range(void)
+{
+	const struct memory_range *range = &crash_reserved_mem;
+	int i;
+
+	for (i = 0; i < crashmem_rgns.size; i++) {
+		struct memory_range *r = crashmem_rgns.ranges + i;
+
+		/*
+		 * We assume that crash area is fully contained in
+		 * some larger memory area.
+		 */
+		if (r->start <= range->start && r->end >= range->end) {
+			struct memory_range *new;
+
+			if (r->start == range->start) {
+				if (r->end == range->end) {
+					memcpy(r, r + 1,
+						sizeof(r)
+						* (crashmem_rgns.size - i - 1));
+					crashmem_rgns.size--;
+				} else {
+					r->start = range->end + 1;
+				}
+				break;
+			}
+			if (r->end == range->end) {
+				r->end = range->start - 1;
+				break;
+			}
+
+			/*
+			 * Let's split this area into 2 smaller ones and
+			 * remove excluded range from between. First create
+			 * new entry for the remaining area.
+			 */
+			new = crashmem_rgns.ranges + crashmem_rgns.size;
+			new->start = range->end + 1;
+			new->end = r->end;
+			crashmem_rgns.size++;
+			/*
+			 * Next update this area to end before excluded range.
+			 */
+			r->end = range->start - 1;
+			break;
+		}
+	}
+}
+
+/*
+ * crash_get_memory_ranges() - read system physical memory
+ *
+ * Function reads through system physical memory and stores found memory
+ * regions in @crash_memory_ranges. Number of memory regions found is placed
+ * in @crash_memory_nr_ranges. Regions are sorted in ascending order.
+ *
+ * Returns %0 in case of success and %-1 otherwise (errno is set).
+ */
+static int crash_get_memory_ranges(void)
+{
+	/*
+	 * First read all memory regions that can be considered as
+	 * system memory including the crash area.
+	 */
+	kexec_iomem_for_each_line(NULL, crash_range_callback, NULL);
+
+	if (usablemem_rgns.size != 1) {
+		errno = EINVAL;
+		return -1;
+	}
+
+	/*
+	 * Exclude memory reserved for crashkernel (this may result int
+	 * split memory regions).
+	 */
+	/*
+	 * FIXME:
+	 * Do we have to check crashkernel is within main memory?
+	 */
+	crash_exclude_range();
+
+	return 0;
+}
+
+/*
+ * range_size - Return range size in MiB.
+ */
+
+static unsigned long range_size(const struct memory_range *r)
+{
+	return (r->end - r->start + 1) >> 20;
+}
+
+static void dump_crash_ranges(void)
+{
+	int i;
+
+	if (!kexec_debug)
+		return;
+
+	dbgprintf("%s: kernel: %016llx - %016llx (%ld MiB)\n", __func__,
+		  crash_reserved_mem.start, crash_reserved_mem.end,
+		  range_size(&crash_reserved_mem));
+
+	for (i = 0; i < crashmem_rgns.size; i++) {
+		struct memory_range *r = crashmem_rgns.ranges + i;
+		dbgprintf("%s: RAM:    %016llx - %016llx (%ld MiB)\n", __func__,
+			  r->start, r->end, range_size(r));
+	}
+}
+
+/*
+ * load_crashdump_segments() - create elf core header for /proc/vmcore
+ * @info: kexec info structure
+ * @option: To be appended to kernel command line
+ *
+ * This function loads additional segments which are needed for the dump
+ * capture kernel. It also updates kernel command line passed in
+ * @command_line_extra to have the correct parameters for the dump capture
+ * kernel.
+ *
+ * Return %0 in case of success and %-1 in case of error.
+ */
+
+int load_crashdump_segments(struct kexec_info *info, char **option)
+{
+	unsigned long elfcorehdr;
+	unsigned long bufsz;
+	void *buf;
+	int err;
+
+	/*
+	 * First fetch all the memory (RAM) ranges that we are going to
+	 * pass to the crashdump kernel during panic.
+	 */
+
+	err = crash_get_memory_ranges();
+
+	if (err)
+		return err;
+
+	dump_crash_ranges();
+
+	elf_info.page_offset = arm64_mem.page_offset;
+
+	err = crash_create_elf64_headers(info, &elf_info, crashmem_rgns.ranges,
+		crashmem_rgns.size, &buf, &bufsz, ELF_CORE_HEADER_ALIGN);
+
+	if (err)
+		return err;
+
+	/*
+	 * FIXME: check if we need 128KB alignment here as stated in arm.
+	 */
+	elfcorehdr = add_buffer_phys_virt(info, buf, bufsz, bufsz, 0,
+		crash_reserved_mem.start, crash_reserved_mem.end,
+		-1, 0);
+
+	err = asprintf(option, " elfcorehdr=%#lx@%#lx mem=%#llx",
+			bufsz, elfcorehdr,
+			crash_reserved_mem.end - crash_reserved_mem.start + 1);
+
+	if (err == -1)
+		return err;
+
+	dbgprintf("%s:%s\n", __func__, *option);
+
+	return 0;
+}
+
+void modify_ehdr_for_crashdump(struct mem_ehdr *ehdr)
+{
+	struct mem_phdr *phdr;
+	int i;
+
+	ehdr->e_entry += crash_reserved_mem.start;
+
+	for (i = 0; i < ehdr->e_phnum; i++) {
+		phdr = &ehdr->e_phdr[i];
+		if (phdr->p_type != PT_LOAD)
+			continue;
+		phdr->p_paddr += 
+			(-arm64_mem.memstart + crash_reserved_mem.start);
+	}
+}
+
+void *get_crash_entry(void)
+{
+	return (void *)crash_reserved_mem.start + arm64_mem.text_offset;
+}
diff --git a/kexec/arch/arm64/crashdump-arm64.h b/kexec/arch/arm64/crashdump-arm64.h
new file mode 100644
index 0000000..6457ea7
--- /dev/null
+++ b/kexec/arch/arm64/crashdump-arm64.h
@@ -0,0 +1,26 @@
+/*
+ * crashdump for arm64
+ *
+ * Copyright (c) 2014 Linaro Limited
+ * Author: AKASHI Takahiro <takahiro.akashi@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef CRASHDUMP_ARM64_H
+#define CRASHDUMP_ARM64_H
+
+#include "kexec.h"
+
+#define CRASH_MAX_MEMORY_RANGES	32
+
+extern struct memory_ranges usablemem_rgns;
+extern struct memory_range crash_reserved_mem;
+
+int load_crashdump_segments(struct kexec_info *info, char **option);
+void modify_ehdr_for_crashdump(struct mem_ehdr *ehdr);
+void *get_crash_entry(void);
+
+#endif
diff --git a/kexec/arch/arm64/image-header.h b/kexec/arch/arm64/image-header.h
new file mode 100644
index 0000000..acb839a
--- /dev/null
+++ b/kexec/arch/arm64/image-header.h
@@ -0,0 +1,95 @@
+/*
+ * ARM64 binary image support.
+ * Copyright (C) 2014 Linaro.
+ */
+
+#if !defined(__ARM64_IMAGE_HEADER_H)
+#define __ARM64_IMAGE_HEADER_H
+
+#if !defined(__KERNEL__)
+#include <stdint.h>
+#endif
+
+#if !defined(__ASSEMBLY__)
+
+/**
+ * struct arm64_image_header - arm64 kernel image header.
+ *
+ * @pe_sig: Optional PE format 'MZ' signature.
+ * @branch_code: Reserved for instructions to branch to stext.
+ * @text_offset: The image load offset in LSB byte order.
+ * @image_size: An estimated size of the memory image size in LSB byte order.
+ * @flags: Bit flags:
+ *  Bit 7.0: Image byte order, 1=MSB.
+ * @reserved_1: Reserved.
+ * @magic: Magic number, "ARM\x64".
+ * @pe_header: Optional offset to a PE format header.
+ **/
+
+struct arm64_image_header {
+	uint8_t pe_sig[2];
+	uint16_t branch_code[3];
+	uint64_t text_offset;
+	uint64_t image_size;
+	uint8_t flags[8];
+	uint64_t reserved_1[3];
+	uint8_t magic[4];
+	uint32_t pe_header;
+};
+
+static const uint8_t arm64_image_magic[4] = {'A', 'R', 'M', 0x64U};
+static const uint8_t arm64_image_pe_sig[2] = {'M', 'Z'};
+static const uint64_t arm64_image_flag_7_be = 0x01U;
+
+/**
+ * arm64_header_check_magic - Helper to check the arm64 image header.
+ *
+ * Returns non-zero if header is OK.
+ */
+
+static inline int arm64_header_check_magic(const struct arm64_image_header *h)
+{
+	if (!h)
+		return 0;
+
+	if (!h->text_offset)
+		return 0;
+
+	return (h->magic[0] == arm64_image_magic[0]
+		&& h->magic[1] == arm64_image_magic[1]
+		&& h->magic[2] == arm64_image_magic[2]
+		&& h->magic[3] == arm64_image_magic[3]);
+}
+
+/**
+ * arm64_header_check_pe_sig - Helper to check the arm64 image header.
+ *
+ * Returns non-zero if 'MZ' signature is found.
+ */
+
+static inline int arm64_header_check_pe_sig(const struct arm64_image_header *h)
+{
+	if (!h)
+		return 0;
+
+	return (h->pe_sig[0] == arm64_image_pe_sig[0]
+		&& h->pe_sig[1] == arm64_image_pe_sig[1]);
+}
+
+/**
+ * arm64_header_check_msb - Helper to check the arm64 image header.
+ *
+ * Returns non-zero if the image was built as big endian.
+ */
+
+static inline int arm64_header_check_msb(const struct arm64_image_header *h)
+{
+	if (!h)
+		return 0;
+
+	return !!(h->flags[7] & arm64_image_flag_7_be);
+}
+
+#endif /* !defined(__ASSEMBLY__) */
+
+#endif
diff --git a/kexec/arch/arm64/include/arch/options.h b/kexec/arch/arm64/include/arch/options.h
new file mode 100644
index 0000000..fa4ad2c
--- /dev/null
+++ b/kexec/arch/arm64/include/arch/options.h
@@ -0,0 +1,50 @@
+#if !defined(KEXEC_ARCH_ARM64_OPTIONS_H)
+#define KEXEC_ARCH_ARM64_OPTIONS_H
+
+#define OPT_APPEND	((OPT_MAX)+0)
+#define OPT_DTB		((OPT_MAX)+1)
+#define OPT_INITRD	((OPT_MAX)+2)
+#define OPT_LITE	((OPT_MAX)+3)
+#define OPT_PAGE_OFFSET	((OPT_MAX)+4)
+#define OPT_PORT	((OPT_MAX)+5)
+#define OPT_REUSE_CMDLINE	((OPT_MAX+6))
+#define OPT_ARCH_MAX	((OPT_MAX)+7)
+
+#define KEXEC_ARCH_OPTIONS \
+	KEXEC_OPTIONS \
+	{ "append",       1, NULL, OPT_APPEND }, \
+	{ "command-line", 1, NULL, OPT_APPEND }, \
+	{ "dtb",          1, NULL, OPT_DTB }, \
+	{ "initrd",       1, NULL, OPT_INITRD }, \
+	{ "lite",         0, NULL, OPT_LITE }, \
+	{ "page-offset",  1, NULL, OPT_PAGE_OFFSET }, \
+	{ "port",         1, NULL, OPT_PORT }, \
+	{ "ramdisk",      1, NULL, OPT_INITRD }, \
+	{ "reuse-cmdline", 0, NULL, OPT_REUSE_CMDLINE }, \
+
+#define KEXEC_ARCH_OPT_STR KEXEC_OPT_STR /* Only accept long arch options. */
+#define KEXEC_ALL_OPTIONS KEXEC_ARCH_OPTIONS
+#define KEXEC_ALL_OPT_STR KEXEC_ARCH_OPT_STR
+
+static const char arm64_opts_usage[] __attribute__ ((unused)) =
+"     --append=STRING       Set the kernel command line to STRING.\n"
+"     --command-line=STRING Set the kernel command line to STRING.\n"
+"     --dtb=FILE            Use FILE as the device tree blob.\n"
+"     --initrd=FILE         Use FILE as the kernel initial ramdisk.\n"
+"     --lite                Fast reboot, no memory integrity checks.\n"
+"     --port=ADDRESS        Purgatory output to port ADDRESS.\n"
+"     --ramdisk=FILE        Use FILE as the kernel initial ramdisk.\n"
+"     --reuse-cmdline       Use command line arg of primary kernel.\n";
+
+struct arm64_opts {
+	const char *command_line;
+	const char *dtb;
+	const char *initrd;
+	uint64_t page_offset;
+	uint64_t port;
+	int lite;
+};
+
+extern struct arm64_opts arm64_opts;
+
+#endif
diff --git a/kexec/arch/arm64/include/types.h b/kexec/arch/arm64/include/types.h
new file mode 100644
index 0000000..08f833a
--- /dev/null
+++ b/kexec/arch/arm64/include/types.h
@@ -0,0 +1,16 @@
+#ifndef _TYPES_H_
+#define _TYPES_H_
+
+#define min(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);	\
+	_x < _y ? _x : _y; })
+
+#define max(x,y) ({ \
+	typeof(x) _x = (x);	\
+	typeof(y) _y = (y);	\
+	(void) (&_x == &_y);	\
+	_x > _y ? _x : _y; })
+
+#endif /* _TYPES_H_ */
diff --git a/kexec/arch/arm64/kexec-arm64.c b/kexec/arch/arm64/kexec-arm64.c
new file mode 100644
index 0000000..de9f962
--- /dev/null
+++ b/kexec/arch/arm64/kexec-arm64.c
@@ -0,0 +1,1052 @@
+/*
+ * ARM64 kexec.
+ */
+
+#define _GNU_SOURCE
+
+#include <assert.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <elf.h>
+#include <errno.h>
+#include <getopt.h>
+#include <inttypes.h>
+#include <libfdt.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <sys/stat.h>
+
+#include "dt-ops.h"
+#include "kexec.h"
+#include "crashdump.h"
+#include "crashdump-arm64.h"
+#include "kexec-arm64.h"
+#include "fs2dt.h"
+#include "kexec-syscall.h"
+#include "arch/options.h"
+#include "types.h"
+
+/* Global varables the core kexec routines expect. */
+
+unsigned char reuse_initrd;
+
+off_t initrd_base;
+off_t initrd_size;
+
+const struct arch_map_entry arches[] = {
+	{ "aarch64", KEXEC_ARCH_ARM64 },
+	{ "aarch64_be", KEXEC_ARCH_ARM64 },
+	{ NULL, 0 },
+};
+
+/* arm64 global varables. */
+
+struct arm64_opts arm64_opts;
+struct arm64_mem arm64_mem = {
+	.memstart = UINT64_MAX,
+};
+
+static void set_memstart(uint64_t v)
+{
+	if (arm64_mem.memstart == UINT64_MAX || v < arm64_mem.memstart)
+		arm64_mem.memstart = v;
+}
+
+static int check_memstart(void)
+{
+	return arm64_mem.memstart != UINT64_MAX;
+}
+
+void arch_usage(void)
+{
+	dbgprintf("Build time: %s : %s\n", __DATE__, __TIME__);
+	printf(arm64_opts_usage);
+}
+
+int arch_process_options(int argc, char **argv)
+{
+	static const char short_options[] = KEXEC_OPT_STR "";
+	static const struct option options[] = {
+		KEXEC_ARCH_OPTIONS
+		{ 0 }
+	};
+	int opt;
+	const char *append = NULL;
+	char *tmp_cmdline = NULL;
+
+	for (opt = 0; opt != -1; ) {
+		opt = getopt_long(argc, argv, short_options, options, 0);
+
+		switch (opt) {
+		case OPT_APPEND:
+			append = optarg;
+			break;
+		case OPT_REUSE_CMDLINE:
+			tmp_cmdline = get_command_line();
+			break;
+		case OPT_DTB:
+			arm64_opts.dtb = optarg;
+			break;
+		case OPT_INITRD:
+			arm64_opts.initrd = optarg;
+			break;
+		case OPT_LITE:
+			arm64_opts.lite = 1;
+			break;
+		case OPT_PORT:
+			arm64_opts.port = strtoull(optarg, NULL, 0);
+			break;
+		case OPT_PAGE_OFFSET:
+			arm64_opts.page_offset = strtoull(optarg, NULL, 0);
+			break;
+		default:
+			break; /* Ignore core and unknown options. */
+		}
+	}
+
+	arm64_opts.command_line = concat_cmdline(tmp_cmdline, append);
+	kexec_debug = 1; // FIXME: for debugging only.
+
+	dbgprintf("%s:%d: command_line: %s\n", __func__, __LINE__,
+		arm64_opts.command_line);
+	dbgprintf("%s:%d: initrd: %s\n", __func__, __LINE__,
+		arm64_opts.initrd);
+	dbgprintf("%s:%d: dtb: %s\n", __func__, __LINE__, arm64_opts.dtb);
+	dbgprintf("%s:%d: lite: %d\n", __func__, __LINE__, arm64_opts.lite);
+	dbgprintf("%s:%d: port: 0x%" PRIx64 "\n", __func__, __LINE__,
+		arm64_opts.port);
+
+	return 0;
+}
+
+struct dtb {
+	char *buf;
+	off_t size;
+	const char *name;
+	const char *path;
+};
+
+static void dump_reservemap(const struct dtb *dtb)
+{
+	int i;
+
+	for (i = 0; ; i++) {
+		uint64_t address;
+		uint64_t size;
+
+		fdt_get_mem_rsv(dtb->buf, i, &address, &size);
+
+		if (!size)
+			break;
+
+		dbgprintf("%s: %s {%" PRIx64 ", %" PRIx64 "}\n", __func__,
+			dtb->name, address, size);
+	}
+}
+
+enum cpu_enable_method {
+	cpu_enable_method_unknown,
+	cpu_enable_method_psci,
+	cpu_enable_method_spin_table,
+};
+
+/**
+ * struct cpu_properties - Various properties from a device tree cpu node.
+ *
+ * These properties will be valid over a dtb re-size.
+ */
+
+struct cpu_properties {
+	uint64_t hwid;
+	uint64_t cpu_release_addr;
+	char node_path[128];
+	char enable_method[128];
+	enum cpu_enable_method type;
+};
+
+/**
+ * read_cpu_properties - Helper to read the device tree cpu properties.
+ */
+
+static int read_cpu_properties(struct cpu_properties *cp,
+	const struct dtb *dtb, int node_offset, unsigned int address_cells)
+{
+	int result;
+	const void *data;
+
+	result = fdt_get_path(dtb->buf, node_offset, cp->node_path,
+		sizeof(cp->node_path));
+
+	if (result < 0) {
+		fprintf(stderr, "kexec: %s:%d: %s: fdt_get_path failed: %s\n",
+			__func__, __LINE__, dtb->name, fdt_strerror(result));
+		return result;
+	}
+
+	data = fdt_getprop(dtb->buf, node_offset, "device_type", &result);
+
+	if (!data) {
+		dbgprintf("%s: %s (%s) read device_type failed: %s\n",
+			__func__, dtb->name, cp->node_path,
+			fdt_strerror(result));
+		return result == -FDT_ERR_NOTFOUND ? 0 : result;
+	}
+
+	if (strcmp(data, "cpu")) {
+		dbgprintf("%s: %s (%s): '%s'\n", __func__, dtb->name,
+			cp->node_path, (const char *)data);
+		return 0;
+	}
+
+	data = fdt_getprop(dtb->buf, node_offset, "reg", &result);
+
+	if (!data) {
+		fprintf(stderr, "kexec: %s:%d: read hwid failed: %s\n",
+			__func__, __LINE__, fdt_strerror(result));
+		return result;
+	}
+
+	cp->hwid = (address_cells == 1) ? fdt32_to_cpu(*(uint32_t *)data) :
+		fdt64_to_cpu(*(uint64_t *)data);
+
+	data = fdt_getprop(dtb->buf, node_offset, "enable-method", &result);
+
+	if (!data) {
+		fprintf(stderr,
+			"kexec: %s:%d: read enable_method failed: %s\n",
+			__func__, __LINE__, fdt_strerror(result));
+		return result;
+	}
+
+	strncpy(cp->enable_method, data, sizeof(cp->enable_method));
+	cp->enable_method[sizeof(cp->enable_method) - 1] = 0;
+
+	if (!strcmp(cp->enable_method, "psci")) {
+		cp->type = cpu_enable_method_psci;
+		return 1;
+	}
+
+	if (strcmp(cp->enable_method, "spin-table")) {
+		cp->type = cpu_enable_method_unknown;
+		return -1;
+	}
+
+	cp->type = cpu_enable_method_spin_table;
+
+	data = fdt_getprop(dtb->buf, node_offset, "cpu-release-addr", &result);
+
+	if (!data) {
+		fprintf(stderr, "kexec: %s:%d: "
+			"read cpu-release-addr failed: %s\n",
+			__func__, __LINE__, fdt_strerror(result));
+		return result;
+	}
+
+	cp->cpu_release_addr = fdt64_to_cpu(*(uint64_t *)data);
+
+	return 1;
+}
+
+static int check_cpu_properties(const struct cpu_properties *cp_1,
+	const struct cpu_properties *cp_2)
+{
+	assert(cp_1->hwid == cp_2->hwid);
+
+	if (cp_1->type != cp_2->type) {
+		fprintf(stderr,
+			"%s:%d: hwid-%" PRIx64 ": "
+			"Error: Different enable methods: %s -> %s\n",
+			__func__, __LINE__, cp_1->hwid, cp_1->enable_method,
+			cp_2->enable_method);
+		return -EINVAL;
+	}
+
+	if (cp_1->type != cpu_enable_method_psci
+		&& cp_1->type != cpu_enable_method_spin_table) {
+		fprintf(stderr,
+			"%s:%d: hwid-%" PRIx64 ": "
+			"Warning: Unknown enable method: %s.\n",
+			__func__, __LINE__, cp_1->hwid,
+			cp_1->enable_method);
+	}
+
+	if (cp_1->type == cpu_enable_method_spin_table) {
+		if (cp_1->cpu_release_addr != cp_2->cpu_release_addr) {
+			fprintf(stderr, "%s:%d: hwid-%" PRIx64 ": "
+				"Error: Different cpu-release-addr: "
+				"%" PRIx64 " -> %" PRIx64 ".\n",
+				__func__, __LINE__,
+				cp_1->hwid,
+				cp_2->cpu_release_addr,
+				cp_1->cpu_release_addr);
+			return -EINVAL;
+		}
+	}
+
+	dbgprintf("%s: hwid-%" PRIx64 ": OK\n", __func__, cp_1->hwid);
+
+	return 0;
+}
+
+struct cpu_info {
+	unsigned int cpu_count;
+	struct cpu_properties *cp;
+};
+
+static int read_cpu_info(struct cpu_info *info, const struct dtb *dtb)
+{
+	int i;
+	int offset;
+	int result;
+	int depth;
+	const void *data;
+	unsigned int address_cells;
+
+	offset = fdt_subnode_offset(dtb->buf, 0, "cpus");
+
+	if (offset < 0) {
+		fprintf(stderr, "kexec: %s:%d: read cpus node failed: %s\n",
+			__func__, __LINE__, fdt_strerror(offset));
+		return offset;
+	}
+
+	data = fdt_getprop(dtb->buf, offset, "#address-cells", &result);
+
+	if (!data) {
+		fprintf(stderr,
+			"kexec: %s:%d: read cpus address-cells failed: %s\n",
+			__func__, __LINE__, fdt_strerror(result));
+		return result;
+	}
+
+	address_cells = fdt32_to_cpu(*(uint32_t *)data);
+
+	if (address_cells < 1 || address_cells > 2) {
+		fprintf(stderr,
+			"kexec: %s:%d: bad cpus address-cells value: %u\n",
+			__func__, __LINE__, address_cells);
+		return -EINVAL;
+	}
+
+	for (i = 0, depth = 0; ; i++) {
+		info->cp = realloc(info->cp, (i + 1) * sizeof(*info->cp));
+
+		if (!info->cp) {
+			fprintf(stderr, "kexec: %s:%d: malloc failed: %s\n",
+				__func__, __LINE__, fdt_strerror(offset));
+			result = -ENOMEM;
+			goto on_error;
+		}
+
+next_node:
+		memset(&info->cp[i], 0, sizeof(*info->cp));
+
+		offset = fdt_next_node(dtb->buf, offset, &depth);
+
+		if (offset < 0) {
+			fprintf(stderr, "kexec: %s:%d: "
+				"read cpu node failed: %s\n", __func__,
+				__LINE__, fdt_strerror(offset));
+			result = offset;
+			goto on_error;
+		}
+
+		if (depth != 1)
+			break;
+
+		result = read_cpu_properties(&info->cp[i], dtb, offset,
+			address_cells);
+
+		if (result == 0)
+			goto next_node;
+
+		if (result < 0)
+			goto on_error;
+
+		if (info->cp[i].type == cpu_enable_method_psci)
+			dbgprintf("%s: %s cpu-%d (%s): hwid-%" PRIx64 ", '%s'\n",
+				__func__, dtb->name, i, info->cp[i].node_path,
+				info->cp[i].hwid,
+				info->cp[i].enable_method);
+		else
+			dbgprintf("%s: %s cpu-%d (%s): hwid-%" PRIx64 ", '%s', "
+				"cpu-release-addr %" PRIx64 "\n",
+				__func__, dtb->name, i, info->cp[i].node_path,
+				info->cp[i].hwid,
+				info->cp[i].enable_method,
+				info->cp[i].cpu_release_addr);
+	}
+
+	info->cpu_count = i;
+	return 0;
+
+on_error:
+	free(info->cp);
+	info->cp = NULL;
+	return result;
+}
+
+static int check_cpu_nodes(const struct dtb *dtb_1, const struct dtb *dtb_2)
+{
+	int result;
+	unsigned int cpu_1;
+	struct cpu_info info_1;
+	struct cpu_info info_2;
+	unsigned int to_process;
+
+	memset(&info_1, 0, sizeof(info_1));
+	memset(&info_2, 0, sizeof(info_2));
+
+	result = read_cpu_info(&info_1, dtb_1);
+
+	if (result)
+		goto on_exit;
+
+	result = read_cpu_info(&info_2, dtb_2);
+
+	if (result)
+		goto on_exit;
+
+	to_process = info_1.cpu_count < info_2.cpu_count
+		? info_1.cpu_count : info_2.cpu_count;
+
+	for (cpu_1 = 0; cpu_1 < info_1.cpu_count; cpu_1++) {
+		struct cpu_properties *cp_1 = &info_1.cp[cpu_1];
+		unsigned int cpu_2;
+
+		for (cpu_2 = 0; cpu_2 < info_2.cpu_count; cpu_2++) {
+			struct cpu_properties *cp_2 = &info_2.cp[cpu_2];
+
+			if (cp_1->hwid != cp_2->hwid)
+				continue;
+
+			to_process--;
+
+			result = check_cpu_properties(cp_1, cp_2);
+
+			if (result)
+				goto on_exit;
+		}
+	}
+
+	if (to_process) {
+		fprintf(stderr, "kexec: %s:%d: Warning: "
+			"Failed to process %u CPUs.\n",
+			__func__, __LINE__, to_process);
+		result = -EINVAL;
+		goto on_exit;
+	}
+
+on_exit:
+	free(info_1.cp);
+	free(info_2.cp);
+	return result;
+}
+
+static int set_bootargs(struct dtb *dtb, const char *command_line)
+{
+	int result;
+
+	if (!command_line || !command_line[0])
+		return 0;
+
+	result = dtb_set_bootargs((char **)&dtb->buf, &dtb->size, command_line);
+
+	if (result)
+		fprintf(stderr,
+			"kexec: Set device tree bootargs failed.\n");
+
+	return result;
+}
+
+static int read_proc_dtb(struct dtb *dtb, const char *command_line)
+{
+	int result;
+	struct stat s;
+	static const char path[] = "/proc/device-tree";
+
+	result = stat(path, &s);
+
+	if (result) {
+		dbgprintf("%s: %s\n", __func__, strerror(errno));
+		return -1;
+	}
+
+	dtb->path = path;
+	create_flatten_tree((char **)&dtb->buf, &dtb->size,
+		(command_line && command_line[0]) ? command_line : NULL);
+
+	return 0;
+}
+
+static int read_sys_dtb(struct dtb *dtb, const char *command_line)
+{
+	int result;
+	struct stat s;
+	static const char path[] = "/sys/firmware/fdt";
+
+	result = stat(path, &s);
+
+	if (result) {
+		dbgprintf("%s: %s\n", __func__, strerror(errno));
+		return -1;
+	}
+
+	dtb->path = path;
+	dtb->buf = slurp_file("/sys/firmware/fdt", &dtb->size);
+
+	return set_bootargs(dtb, command_line);
+}
+
+static int read_1st_dtb(struct dtb *dtb, const char *command_line)
+{
+	int result;
+
+	result = read_sys_dtb(dtb, command_line);
+
+	if (!result)
+		goto on_success;
+
+	result = read_proc_dtb(dtb, command_line);
+
+	if (!result)
+		goto on_success;
+
+	return -1;
+
+on_success:
+	dbgprintf("%s: found %s\n", __func__, dtb->path);
+	return 0;
+}
+
+static int setup_2nd_dtb(char *command_line, const struct dtb *dtb_1,
+	struct dtb *dtb_2)
+{
+	int result;
+
+	result = fdt_check_header(dtb_2->buf);
+
+	if (result) {
+		fprintf(stderr, "kexec: Invalid 2nd device tree.\n");
+		return -EINVAL;
+	}
+
+	result = set_bootargs(dtb_2, command_line);
+
+	dump_reservemap(dtb_2);
+
+	return result;
+}
+
+static uint64_t read_sink(const char *command_line)
+{
+	uint64_t v;
+	const char *p;
+
+	if (arm64_opts.port)
+		return arm64_opts.port;
+
+#if defined(ARM64_DEBUG_PORT)
+	return (uint64_t)(ARM64_DEBUG_PORT);
+#endif
+	if (!command_line)
+		return 0;
+
+	p = strstr(command_line, "earlyprintk=");
+
+	if (!p)
+		return 0;
+
+	while (*p != ',')
+		p++;
+
+	p++;
+
+	while (isspace(*p))
+		p++;
+
+	if (*p == 0)
+		return 0;
+
+	errno = 0;
+
+	v = strtoull(p, NULL, 0);
+
+	if (errno)
+		return 0;
+
+	return v;
+}
+
+/**
+ * arm64_load_other_segments - Prepare the dtb, initrd and purgatory segments.
+ */
+
+int arm64_load_other_segments(struct kexec_info *info,
+	unsigned long kernel_entry, char *option)
+{
+	int result, i;
+	struct mem_ehdr ehdr;
+	unsigned long dtb_base;
+	unsigned long arm64_ram_start = -1;
+	unsigned long arm64_ram_end = 0;
+	unsigned long hole_min, hole_max;
+	char *initrd_buf = NULL;
+	uint64_t purgatory_sink;
+	struct dtb dtb_1 = {.name = "dtb_1"};
+	struct dtb dtb_2 = {.name = "dtb_2"};
+	char command_line[COMMAND_LINE_SIZE] = "";
+
+	dbgprintf("%s:%d: add '%s' to command line\n", __func__, __LINE__,
+		option);
+
+	if (arm64_opts.command_line) {
+		strncpy(command_line, arm64_opts.command_line,
+			sizeof(command_line));
+		command_line[sizeof(command_line) - 1] = 0;
+	}
+
+	if (option && option[0])
+		strcat(command_line, option);
+
+	purgatory_sink = read_sink(command_line);
+	dbgprintf("%s:%d: purgatory sink: 0x%" PRIx64 "\n", __func__, __LINE__,
+		purgatory_sink);
+
+	if (arm64_opts.dtb) {
+		dtb_2.buf = slurp_file(arm64_opts.dtb, &dtb_2.size);
+		assert(dtb_2.buf);
+	}
+
+	result = read_1st_dtb(&dtb_1, command_line);
+
+	if (result && !arm64_opts.dtb) {
+		fprintf(stderr, "kexec: Error: No device tree available.\n");
+		return result;
+	}
+
+	if (result && arm64_opts.dtb)
+		dtb_1 = dtb_2;
+	else if (!result && !arm64_opts.dtb)
+		dtb_2 = dtb_1;
+
+	result = setup_2nd_dtb(command_line, &dtb_1, &dtb_2);
+
+	if (result)
+		return result;
+	
+	result =  check_cpu_nodes(&dtb_1, &dtb_2);
+
+	if (result)
+		return result;
+
+	/*
+	 * Put the DTB after the kernel with an alignment of 128 KiB, giving
+	 * a max supported DTB size of 128 KiB (worst case).  Also add 2 KiB
+	 * to the DTB size for any DTB growth.
+	 */
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		hole_min = crash_reserved_mem.start + arm64_mem.text_offset
+				+ arm64_mem.image_size;
+		hole_max = crash_reserved_mem.end;
+	} else {
+		hole_min = arm64_mem.memstart + arm64_mem.text_offset
+				+ arm64_mem.image_size;
+		hole_max = ULONG_MAX;
+	}
+
+	if (arm64_opts.initrd) {
+		initrd_buf = slurp_file(arm64_opts.initrd, &initrd_size);
+
+		if (!initrd_buf)
+			fprintf(stderr, "kexec: Empty ramdisk file.\n");
+		else {
+			/* Put the initrd after the DTB with an alignment of
+			 * page size. */
+
+			initrd_base = add_buffer_phys_virt(info, initrd_buf,
+				initrd_size, initrd_size, 0,
+				hole_min, hole_max, 1, 0);
+
+			dbgprintf("initrd: base %lx, size %lxh (%ld)\n",
+				initrd_base, initrd_size, initrd_size);
+
+			if (initrd_base == ULONG_MAX)
+				return -ENOMEM;
+
+			result = dtb_set_initrd((char **)&dtb_2.buf,
+				&dtb_2.size, initrd_base,
+				initrd_base + initrd_size);
+
+			if (result)
+				return result;
+		}
+	}
+
+	dtb_base = add_buffer_phys_virt(info, dtb_2.buf, dtb_2.size, dtb_2.size,
+			128UL * 1024, hole_min, hole_max, 1, 0);
+
+	dbgprintf("dtb:    base %lx, size %lxh (%ld)\n", dtb_base, dtb_2.size,
+		dtb_2.size);
+
+	if (dtb_base == ULONG_MAX)
+		return -ENOMEM;
+
+	if (arm64_opts.lite)
+		info->entry = (void *)kernel_entry;
+	else {
+		result = build_elf_rel_info(purgatory, purgatory_size, &ehdr,
+			0);
+
+		if (result < 0) {
+			fprintf(stderr, "%s: Error: "
+				"build_elf_rel_info failed.\n", __func__);
+			return -EBADF;
+		}
+
+		elf_rel_build_load(info, &info->rhdr, purgatory, purgatory_size,
+			hole_min, hole_max, 1, 0);
+
+		info->entry = (void *)elf_rel_get_addr(&info->rhdr,
+			"purgatory_start");
+
+		elf_rel_set_symbol(&info->rhdr, "arm64_sink", &purgatory_sink,
+			sizeof(purgatory_sink));
+
+		elf_rel_set_symbol(&info->rhdr, "arm64_kernel_entry",
+			&kernel_entry, sizeof(kernel_entry));
+
+		elf_rel_set_symbol(&info->rhdr, "arm64_dtb_addr", &dtb_base,
+				sizeof(dtb_base));
+		for (i = 0; i < info->nr_segments; i++) {
+			arm64_ram_start = min(arm64_ram_start,
+					(unsigned long)info->segment[i].mem);
+			arm64_ram_end = max(arm64_ram_end,
+				((unsigned long)info->segment[i].mem + 
+				info->segment[i].memsz));
+		}
+		elf_rel_set_symbol(&info->rhdr, "arm64_ram_start",
+				&arm64_ram_start, sizeof(arm64_ram_start));
+		elf_rel_set_symbol(&info->rhdr, "arm64_ram_end",
+				&arm64_ram_end, sizeof(arm64_ram_end));
+	}
+
+	return 0;
+}
+
+unsigned long virt_to_phys(unsigned long v)
+{
+	unsigned long p;
+
+	assert(arm64_mem.page_offset);
+	assert(check_memstart());
+
+	p = v - arm64_mem.page_offset + arm64_mem.memstart;
+
+	dbgprintf("%s: %016lx -> %016lx\n", __func__, v, p);
+	return p;
+}
+
+unsigned long phys_to_virt(struct crash_elf_info *UNUSED(elf_info),
+	unsigned long p)
+{
+	unsigned long v;
+
+	assert(arm64_mem.page_offset);
+	assert(check_memstart());
+
+	v = p - arm64_mem.memstart + arm64_mem.page_offset;
+
+	dbgprintf("%s: %016lx -> %016lx\n", __func__, p, v);
+	return v;
+}
+
+void add_segment(struct kexec_info *info, const void *buf, size_t bufsz,
+	unsigned long base, size_t memsz)
+{
+	add_segment_phys_virt(info, buf, bufsz, base, memsz, 1);
+}
+
+int arm64_process_image_header(const struct arm64_image_header *h)
+{
+#if !defined(KERNEL_IMAGE_SIZE)
+# define KERNEL_IMAGE_SIZE (768 * 1024)
+#endif
+
+	if (!arm64_header_check_magic(h))
+		return -EINVAL;
+
+	if (h->image_size) {
+		arm64_mem.text_offset = le64_to_cpu(h->text_offset);
+		arm64_mem.image_size = le64_to_cpu(h->image_size);
+	} else {
+		/* For 3.16 and older kernels. */
+		arm64_mem.text_offset = 0x80000;
+		arm64_mem.image_size = KERNEL_IMAGE_SIZE;
+	}
+
+	return 0;
+}
+
+static int get_memory_ranges_dt(struct memory_range *array, unsigned int *count)
+{
+	struct region {uint64_t base; uint64_t size;};
+	struct dtb dtb = {.name = "range_dtb"};
+	int offset;
+	int result;
+
+	*count = 0;
+
+	result = read_1st_dtb(&dtb, NULL);
+
+	if (result) {
+		goto on_error;
+	}
+
+	result = fdt_check_header(dtb.buf);
+
+	if (result) {
+		dbgprintf("%s:%d: %s: fdt_check_header failed:%s\n", __func__,
+			__LINE__, dtb.path, fdt_strerror(result));
+		goto on_error;
+	}
+
+	for (offset = 0; ; ) {
+		const struct region *region;
+		const struct region *end;
+		int len;
+
+		offset = fdt_subnode_offset(dtb.buf, offset, "memory");
+
+		if (offset == -FDT_ERR_NOTFOUND)
+			break;
+
+		if (offset <= 0) {
+			dbgprintf("%s:%d: fdt_subnode_offset failed: %d %s\n",
+				__func__, __LINE__, offset,
+				fdt_strerror(offset));
+			goto on_error;
+		}
+
+		dbgprintf("%s:%d: node_%d %s\n", __func__, __LINE__, offset,
+			fdt_get_name(dtb.buf, offset, NULL));
+
+		region = fdt_getprop(dtb.buf, offset, "reg", &len);
+
+		if (region <= 0) {
+			dbgprintf("%s:%d: fdt_getprop failed: %d %s\n",
+				__func__, __LINE__, offset,
+				fdt_strerror(offset));
+			goto on_error;
+		}
+
+		for (end = region + len / sizeof(*region);
+			region < end && *count < KEXEC_SEGMENT_MAX;
+			region++) {
+			struct memory_range r;
+
+			r.type = RANGE_RAM;
+			r.start = fdt64_to_cpu(region->base);
+			r.end = r.start + fdt64_to_cpu(region->size);
+
+			if (!region->size) {
+				dbgprintf("%s:%d: SKIP: %016llx - %016llx\n",
+					__func__, __LINE__, r.start, r.end);
+				continue;
+			}
+
+			dbgprintf("%s:%d:  RAM: %016llx - %016llx\n", __func__,
+				__LINE__, r.start, r.end);
+
+			array[(*count)++] = r;
+
+			set_memstart(r.start);
+		}
+	}
+
+	if (!*count) {
+		dbgprintf("%s:%d: %s: No RAM found.\n", __func__, __LINE__,
+			dtb.path);
+		goto on_error;
+	}
+
+	dbgprintf("%s:%d: %s: Success\n", __func__, __LINE__, dtb.path);
+	result = 0;
+	goto on_exit;
+
+on_error:
+	fprintf(stderr, "%s:%d: %s: Unusable device-tree file\n", __func__,
+		__LINE__, dtb.path);
+	result = -1;
+
+on_exit:
+	free(dtb.buf);
+	return result;
+}
+
+static int get_memory_ranges_iomem(struct memory_range *array,
+	unsigned int *count)
+{
+	const char *iomem;
+	char line[MAX_LINE];
+	FILE *fp;
+
+	*count = 0;
+
+	iomem = proc_iomem();
+	fp = fopen(iomem, "r");
+
+	if (!fp) {
+		fprintf(stderr, "Cannot open %s: %s\n", iomem, strerror(errno));
+		return -1;
+	}
+
+	while(fgets(line, sizeof(line), fp) != 0) {
+		struct memory_range r;
+		char *str;
+		int consumed;
+
+		if (*count >= KEXEC_SEGMENT_MAX)
+			break;
+
+		if (sscanf(line, "%Lx-%Lx : %n", &r.start, &r.end, &consumed)
+			!= 2)
+			continue;
+
+		str = line + consumed;
+		r.end++;
+
+		if (memcmp(str, "System RAM\n", 11)) {
+			dbgprintf("%s:%d: SKIP: %016Lx - %016Lx : %s", __func__,
+				__LINE__, r.start, r.end, str);
+			continue;
+		}
+
+		r.type = RANGE_RAM;
+
+		dbgprintf("%s:%d: RAM: %016llx - %016llx : %s", __func__,
+			__LINE__, r.start, r.end, str);
+
+		array[(*count)++] = r;
+
+		set_memstart(r.start);
+	}
+
+	fclose(fp);
+
+	if (!*count) {
+		dbgprintf("%s:%d: failed: No RAM found.\n", __func__, __LINE__);
+		return -1;
+	}
+
+	dbgprintf("%s:%d: Success\n", __func__, __LINE__);
+	return 0;
+}
+
+int get_memory_ranges(struct memory_range **range, int *ranges,
+	unsigned long kexec_flags)
+{
+	static struct memory_range array[KEXEC_SEGMENT_MAX];
+	unsigned int count;
+	int result;
+
+	result = get_memory_ranges_dt(array, &count);
+
+	if (result)
+		result = get_memory_ranges_iomem(array, &count);
+
+	*range = result ? NULL : array;
+	*ranges = result ? 0 : count;
+
+	return result;
+}
+
+struct file_type file_type[] = {
+	{"elf-arm64", elf_arm64_probe, elf_arm64_load, elf_arm64_usage},
+	{"image-arm64", image_arm64_probe, image_arm64_load, image_arm64_usage},
+};
+
+int file_types = sizeof(file_type) / sizeof(file_type[0]);
+
+int arch_compat_trampoline(struct kexec_info *info)
+{
+	return 0;
+}
+
+int machine_verify_elf_rel(struct mem_ehdr *ehdr)
+{
+	return (ehdr->e_machine == EM_AARCH64);
+}
+
+void machine_apply_elf_rel(struct mem_ehdr *ehdr, unsigned long r_type,
+	void *ptr, unsigned long address, unsigned long value)
+{
+#if !defined(R_AARCH64_ABS64)
+# define R_AARCH64_ABS64 257
+#endif
+
+#if !defined(R_AARCH64_LD_PREL_LO19)
+# define R_AARCH64_LD_PREL_LO19 273
+#endif
+
+#if !defined(R_AARCH64_ADR_PREL_LO21)
+# define R_AARCH64_ADR_PREL_LO21 274
+#endif
+
+#if !defined(R_AARCH64_JUMP26)
+# define R_AARCH64_JUMP26 282
+#endif
+
+#if !defined(R_AARCH64_CALL26)
+# define R_AARCH64_CALL26 283
+#endif
+
+	uint64_t *location = (uint64_t *)ptr;
+	uint64_t data = *location;
+	const char *type = NULL;
+
+	switch(r_type) {
+	case R_AARCH64_ABS64:
+		type = "ABS64";
+		*location += value;
+		break;
+	case R_AARCH64_LD_PREL_LO19:
+		type = "LD_PREL_LO19";
+		*location += ((value - address) << 3) & 0xffffe0;
+		break;
+	case R_AARCH64_ADR_PREL_LO21:
+		if (value & 3)
+			die("%s: ERROR Unaligned value: %lx\n", __func__,
+				value);
+		type = "ADR_PREL_LO21";
+		*location += ((value - address) << 3) & 0xffffe0;
+		break;
+	case R_AARCH64_JUMP26:
+		type = "JUMP26";
+		*location += ((value - address) >> 2) & 0x3ffffff;
+		break;
+	case R_AARCH64_CALL26:
+		type = "CALL26";
+		*location += ((value - address) >> 2) & 0x3ffffff;
+		break;
+	default:
+		die("%s: ERROR Unknown type: %lu\n", __func__, r_type);
+		break;
+	}
+
+	dbgprintf("%s: %s %lx->%lx\n", __func__, type, data, *location);
+}
+
+void arch_reuse_initrd(void)
+{
+	reuse_initrd = 1;
+}
+
+void arch_update_purgatory(struct kexec_info *UNUSED(info))
+{
+}
diff --git a/kexec/arch/arm64/kexec-arm64.h b/kexec/arch/arm64/kexec-arm64.h
new file mode 100644
index 0000000..7e4d056
--- /dev/null
+++ b/kexec/arch/arm64/kexec-arm64.h
@@ -0,0 +1,53 @@
+/*
+ * ARM64 kexec.
+ */
+
+#if !defined(KEXEC_ARM64_H)
+#define KEXEC_ARM64_H
+
+#include <stdbool.h>
+#include <sys/types.h>
+
+#include "image-header.h"
+#include "kexec.h"
+
+#define KEXEC_SEGMENT_MAX 16
+
+#define BOOT_BLOCK_VERSION 17
+#define BOOT_BLOCK_LAST_COMP_VERSION 16
+#define COMMAND_LINE_SIZE 512
+
+#define ARM64_DEFAULT_PAGE_OFFSET 0xfffffe0000000000
+
+int elf_arm64_probe(const char *kernel_buf, off_t kernel_size);
+int elf_arm64_load(int argc, char **argv, const char *kernel_buf,
+	off_t kernel_size, struct kexec_info *info);
+void elf_arm64_usage(void);
+
+int image_arm64_probe(const char *kernel_buf, off_t kernel_size);
+int image_arm64_load(int argc, char **argv, const char *kernel_buf,
+	off_t kernel_size, struct kexec_info *info);
+void image_arm64_usage(void);
+
+struct memory_ranges usablemem_rgns;
+off_t initrd_base;
+off_t initrd_size;
+
+/**
+ * struct arm64_mem - Memory layout info.
+ */
+
+struct arm64_mem {
+	uint64_t text_offset;
+	uint64_t image_size;
+	uint64_t page_offset;
+	uint64_t memstart;
+};
+
+extern struct arm64_mem arm64_mem;
+
+int arm64_process_image_header(const struct arm64_image_header *h);
+int arm64_load_other_segments(struct kexec_info *info,
+	unsigned long kernel_entry, char *option);
+
+#endif
diff --git a/kexec/arch/arm64/kexec-elf-arm64.c b/kexec/arch/arm64/kexec-elf-arm64.c
new file mode 100644
index 0000000..9fda5e5
--- /dev/null
+++ b/kexec/arch/arm64/kexec-elf-arm64.c
@@ -0,0 +1,141 @@
+/*
+ * ARM64 kexec elf support.
+ */
+
+#define _GNU_SOURCE
+
+#include <assert.h>
+#include <elf.h>
+#include <errno.h>
+#include <getopt.h>
+#include <libfdt.h>
+#include <stdlib.h>
+
+#include "crashdump-arm64.h"
+#include "dt-ops.h"
+#include "kexec-arm64.h"
+#include "fs2dt.h"
+#include "kexec-syscall.h"
+#include "arch/options.h"
+
+int elf_arm64_probe(const char *kernel_buf, off_t kernel_size)
+{
+	int result;
+	struct mem_ehdr ehdr;
+
+	result = build_elf_exec_info(kernel_buf, kernel_size, &ehdr, 0);
+
+	if (result < 0) {
+		dbgprintf("%s: Not an ELF executable.\n", __func__);
+		goto on_exit;
+	}
+
+	if (ehdr.e_machine != EM_AARCH64) {
+		dbgprintf("%s: Not an AARCH64 ELF executable.\n", __func__);
+		result = -EINVAL;
+		goto on_exit;
+	}
+
+	result = 0;
+
+on_exit:
+	free_elf_info(&ehdr);
+	return result;
+}
+
+int elf_arm64_load(int argc, char **argv, const char *kernel_buf,
+	off_t kernel_size, struct kexec_info *info)
+{
+	char *header_option = NULL;
+	int result;
+	struct mem_ehdr ehdr;
+	bool found_header;
+	int i;
+
+	/* Parse the Elf file */
+	result = build_elf_exec_info(kernel_buf, kernel_size, &ehdr, 0);
+
+	if (result < 0) {
+		dbgprintf("%s: build_elf_exec_info failed\n", __func__);
+		goto exit;
+	}
+
+	/* Find and process the arm64 image header. */
+
+	for (i = 0, found_header = false; i < ehdr.e_phnum; i++) {
+		struct mem_phdr *phdr = &ehdr.e_phdr[i];
+		const struct arm64_image_header *h;
+
+		if (phdr->p_type != PT_LOAD)
+			continue;
+
+		h = (const struct arm64_image_header *)(kernel_buf
+			+ phdr->p_offset);
+
+		if (arm64_process_image_header(h))
+			continue;
+
+		found_header = true;
+
+		arm64_mem.page_offset = phdr->p_vaddr - arm64_mem.text_offset;
+
+		dbgprintf("%s: PE format: %s\n", __func__,
+			(arm64_header_check_pe_sig(h) ? "yes" : "no"));
+		dbgprintf("p_vaddr: %016llx\n", phdr->p_vaddr);
+
+		break;
+	}
+
+	if (!found_header) {
+		fprintf(stderr, "kexec: Bad arm64 image header.\n");
+		result = -EINVAL;
+		goto exit;
+	}
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		/* allocate and initialize elf core header */
+		result = load_crashdump_segments(info, &header_option);
+
+		if (result) {
+			fprintf(stderr, "kexec: creating eflcorehdr failed.\n");
+			goto exit;
+		}
+
+		/* offset addresses to load vmlinux(elf_exec) in crash memory */
+		modify_ehdr_for_crashdump(&ehdr);
+	}
+
+	result = elf_exec_load(&ehdr, info);
+
+	if (result) {
+		fprintf(stderr, "kexec: Elf load failed.\n");
+		goto exit;
+	}
+
+	if (info->kexec_flags & KEXEC_ON_CRASH)
+		info->entry = get_crash_entry();
+	else
+		info->entry = (void *)virt_to_phys(ehdr.e_entry);
+
+	dbgprintf("%s: text_offset: %016lx\n", __func__, arm64_mem.text_offset);
+	dbgprintf("%s: image_size:  %016lx\n", __func__, arm64_mem.image_size);
+	dbgprintf("%s: page_offset: %016lx\n", __func__, arm64_mem.page_offset);
+	dbgprintf("%s: memstart:    %016lx\n", __func__, arm64_mem.memstart);
+	dbgprintf("%s: e_entry:     %016llx -> %016lx\n", __func__,
+		ehdr.e_entry, virt_to_phys(ehdr.e_entry));
+
+	result = arm64_load_other_segments(info, (unsigned long)info->entry,
+		header_option);
+exit:
+	free_elf_info(&ehdr);
+	if (header_option)
+		free(header_option);
+	return result;
+}
+
+void elf_arm64_usage(void)
+{
+	printf(
+"     An arm64 ELF file, big or little endian.\n"
+"     Typically vmlinux or a stripped version of vmlinux.\n\n");
+}
diff --git a/kexec/arch/arm64/kexec-image-arm64.c b/kexec/arch/arm64/kexec-image-arm64.c
new file mode 100644
index 0000000..6f8a659
--- /dev/null
+++ b/kexec/arch/arm64/kexec-image-arm64.c
@@ -0,0 +1,140 @@
+/*
+ * ARM64 kexec binary image support.
+ */
+
+#define _GNU_SOURCE
+
+#include <assert.h>
+#include <errno.h>
+#include <getopt.h>
+#include <libfdt.h>
+#include <stdlib.h>
+
+#include "crashdump-arm64.h"
+#include "dt-ops.h"
+#include "image-header.h"
+#include "kexec-arm64.h"
+#include "fs2dt.h"
+#include "kexec-syscall.h"
+#include "arch/options.h"
+
+int image_arm64_probe(const char *kernel_buf, off_t kernel_size)
+{
+	const struct arm64_image_header *h;
+
+	if (kernel_size < sizeof(struct arm64_image_header))
+		return -EINVAL;
+
+	h = (const struct arm64_image_header *)(kernel_buf);
+
+	if (!arm64_header_check_magic(h))
+		return -1;
+
+	dbgprintf("%s: PE format: %s\n", __func__,
+		(arm64_header_check_pe_sig(h) ? "yes" : "no"));
+
+	return 0;
+}
+
+static unsigned long long get_kernel_text_sym(void)
+{
+	const char *kallsyms = "/proc/kallsyms";
+	const char *text = "_text";
+	char sym[128];
+	char line[128];
+	FILE *fp;
+	unsigned long long vaddr;
+	char type;
+
+	fp = fopen(kallsyms, "r");	if (!fp) {
+		fprintf(stderr, "Cannot open %s\n", kallsyms);
+		return 0;
+	}
+
+	while(fgets(line, sizeof(line), fp) != NULL) {
+		if (sscanf(line, "%Lx %c %s", &vaddr, &type, sym) != 3)
+			continue;
+		if (strcmp(sym, text) == 0) {
+			dbgprintf("kernel symbol %s vaddr = %16llx\n", text, vaddr);
+			return vaddr;
+		}
+	}
+
+	fprintf(stderr, "Cannot get kernel %s symbol address\n", text);
+	return 0;
+}
+
+static unsigned long long get_kernel_page_offset(void)
+{
+	unsigned long long text_sym_addr = get_kernel_text_sym();
+	unsigned long long text_page_offset =
+		text_sym_addr & 0xFFFFFFFFFFE00000;
+
+	if(arm64_opts.page_offset) {
+		if (text_page_offset != arm64_opts.page_offset)
+			dbgprintf("User page offset %lx did not match with text page offset %llx\n",
+					arm64_opts.page_offset, text_page_offset); 
+		return arm64_opts.page_offset;
+	} else if(text_page_offset) {
+		dbgprintf("text page offset is %llx\n", text_page_offset);
+		return text_page_offset;
+	} else {
+		return ARM64_DEFAULT_PAGE_OFFSET;
+	}
+}
+
+int image_arm64_load(int argc, char **argv, const char *kernel_buf,
+	off_t kernel_size, struct kexec_info *info)
+{
+	int result;
+	uint64_t start;
+	const struct arm64_image_header *h;
+	char *header_option = NULL;
+
+	h = (const struct arm64_image_header *)(kernel_buf);
+
+	arm64_mem.text_offset = le64_to_cpu(h->text_offset);
+	arm64_mem.image_size = le64_to_cpu(h->image_size);
+
+	arm64_mem.page_offset = get_kernel_page_offset();
+
+	if (info->kexec_flags & KEXEC_ON_CRASH) {
+		result = load_crashdump_segments(info, &header_option);
+
+		if (result) {
+			fprintf(stderr, "kexec: load crashdump segments failed.\n");
+			return -1;
+		}
+		start = crash_reserved_mem.start;
+	} else {
+		result = parse_iomem_single("Kernel code\n", &start, NULL);
+
+		if (result) {
+			fprintf(stderr, "kexec: Could not get kernel code address.\n");
+			return -1;
+		}
+		start -= arm64_mem.text_offset;
+	}
+
+	/* Add kernel */
+	add_segment_phys_virt(info, kernel_buf, kernel_size,
+			start + arm64_mem.text_offset,
+			kernel_size, 0);
+
+	info->entry = (void *)start + arm64_mem.text_offset;
+
+	result = arm64_load_other_segments(info, (unsigned long)info->entry,
+		header_option);
+
+	if (header_option)
+		free(header_option);
+
+	return result;
+}
+
+void image_arm64_usage(void)
+{
+	printf(
+"     An arm64 binary Image file, big or little endian.\n"
+"     --page-offset         Kernel page-offset for binary image load.\n");
+}
diff --git a/kexec/dt-ops.c b/kexec/dt-ops.c
new file mode 100644
index 0000000..bbba986
--- /dev/null
+++ b/kexec/dt-ops.c
@@ -0,0 +1,136 @@
+#include <assert.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <libfdt.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "kexec.h"
+#include "dt-ops.h"
+
+static const char n_chosen[] = "/chosen";
+
+static const char p_bootargs[] = "bootargs";
+static const char p_initrd_start[] = "linux,initrd-start";
+static const char p_initrd_end[] = "linux,initrd-end";
+
+int dtb_set_initrd(char **dtb, off_t *dtb_size, off_t start, off_t end)
+{
+	int result;
+	uint64_t value;
+
+	dbgprintf("%s: start %jd, end %jd, size %jd (%jd KiB)\n",
+		__func__, (intmax_t)start, (intmax_t)end,
+		(intmax_t)(end - start),
+		(intmax_t)(end - start) / 1024);
+
+	value = cpu_to_fdt64(start);
+
+	result = dtb_set_property(dtb, dtb_size, n_chosen, p_initrd_start,
+		&value, sizeof(value));
+
+	if (result)
+		return result;
+
+	value = cpu_to_fdt64(end);
+
+	result = dtb_set_property(dtb, dtb_size, n_chosen, p_initrd_end,
+		&value, sizeof(value));
+
+	if (result) {
+		dtb_delete_property(*dtb, n_chosen, p_initrd_start);
+		return result;
+	}
+
+	return 0;
+}
+
+int dtb_set_bootargs(char **dtb, off_t *dtb_size, const char *command_line)
+{
+	return dtb_set_property(dtb, dtb_size, n_chosen, p_bootargs,
+		command_line, strlen(command_line) + 1);
+}
+
+int dtb_set_property(char **dtb, off_t *dtb_size, const char *node,
+	const char *prop, const void *value, int value_len)
+{
+	int result;
+	int nodeoffset;
+	void *new_dtb;
+	int new_size;
+
+	value_len = FDT_TAGALIGN(value_len);
+
+	new_size = FDT_TAGALIGN(*dtb_size + fdt_node_len(node)
+		+ fdt_prop_len(prop, value_len));
+
+	new_dtb = malloc(new_size);
+
+	if (!new_dtb) {
+		dbgprintf("%s: malloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	result = fdt_open_into(*dtb, new_dtb, new_size);
+
+	if (result) {
+		dbgprintf("%s: fdt_open_into failed: %s\n", __func__,
+			fdt_strerror(result));
+		goto on_error;
+	}
+
+	nodeoffset = fdt_path_offset(new_dtb, node);
+	
+	if (nodeoffset == -FDT_ERR_NOTFOUND) {
+		result = fdt_add_subnode(new_dtb, nodeoffset, node);
+
+		if (result) {
+			dbgprintf("%s: fdt_add_subnode failed: %s\n", __func__,
+				fdt_strerror(result));
+			goto on_error;
+		}
+	} else if (nodeoffset < 0) {
+		dbgprintf("%s: fdt_path_offset failed: %s\n", __func__,
+			fdt_strerror(nodeoffset));
+		goto on_error;
+	}
+
+	result = fdt_setprop(new_dtb, nodeoffset, prop, value, value_len);
+
+	if (result) {
+		dbgprintf("%s: fdt_setprop failed: %s\n", __func__,
+			fdt_strerror(result));
+		goto on_error;
+	}
+	
+	free(*dtb);
+
+	*dtb = new_dtb;
+	*dtb_size = new_size;
+
+	return 0;
+
+on_error:
+	free(new_dtb);
+	return result;
+}
+
+int dtb_delete_property(char *dtb, const char *node, const char *prop)
+{
+	int result;
+	int nodeoffset = fdt_path_offset(dtb, node);
+
+	if (nodeoffset < 0) {
+		dbgprintf("%s: fdt_path_offset failed: %s\n", __func__,
+			fdt_strerror(nodeoffset));
+		return nodeoffset;
+	}
+
+	result = fdt_delprop(dtb, nodeoffset, prop);
+
+	if (result)
+		dbgprintf("%s: fdt_delprop failed: %s\n", __func__,
+			fdt_strerror(nodeoffset));
+
+	return result;
+}
diff --git a/kexec/dt-ops.h b/kexec/dt-ops.h
new file mode 100644
index 0000000..e70d15d
--- /dev/null
+++ b/kexec/dt-ops.h
@@ -0,0 +1,13 @@
+#if !defined(KEXEC_DT_OPS_H)
+#define KEXEC_DT_OPS_H
+
+#include <sys/types.h>
+
+int dtb_set_initrd(char **dtb, off_t *dtb_size, off_t start, off_t end);
+int dtb_set_bootargs(char **dtb, off_t *dtb_size, const char *command_line);
+int dtb_set_property(char **dtb, off_t *dtb_size, const char *node,
+	const char *prop, const void *value, int value_len);
+
+int dtb_delete_property(char *dtb, const char *node, const char *prop);
+
+#endif
diff --git a/kexec/kexec-syscall.h b/kexec/kexec-syscall.h
index ca302eb..d4f7ca8 100644
--- a/kexec/kexec-syscall.h
+++ b/kexec/kexec-syscall.h
@@ -51,8 +51,8 @@
 #ifdef __s390__
 #define __NR_kexec_load		277
 #endif
-#ifdef __arm__
-#define __NR_kexec_load		__NR_SYSCALL_BASE + 347  
+#if defined(__arm__) || defined(__arm64__)
+#define __NR_kexec_load		__NR_SYSCALL_BASE + 347
 #endif
 #if defined(__mips__)
 #define __NR_kexec_load                4311
@@ -91,6 +91,8 @@ static inline long kexec_reboot(void)
 #define KEXEC_ARCH_PPC64   (21 << 16)
 #define KEXEC_ARCH_IA_64   (50 << 16)
 #define KEXEC_ARCH_ARM     (40 << 16)
+#define KEXEC_ARCH_ARM64   (183 << 16)
+/* #define KEXEC_ARCH_AARCH64 (183 << 16) */
 #define KEXEC_ARCH_S390    (22 << 16)
 #define KEXEC_ARCH_SH      (42 << 16)
 #define KEXEC_ARCH_MIPS_LE (10 << 16)
@@ -99,4 +101,45 @@ static inline long kexec_reboot(void)
 
 #define KEXEC_MAX_SEGMENTS 16
 
+#ifdef __i386__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_386
+#endif
+#ifdef __sh__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_SH
+#endif
+#ifdef __cris__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_CRIS
+#endif
+#ifdef __ia64__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_IA_64
+#endif
+#ifdef __powerpc64__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_PPC64
+#else
+ #ifdef __powerpc__
+ #define KEXEC_ARCH_NATIVE	KEXEC_ARCH_PPC
+ #endif
+#endif
+#ifdef __x86_64__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_X86_64
+#endif
+#ifdef __s390x__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_S390
+#endif
+#ifdef __s390__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_S390
+#endif
+#ifdef __arm__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_ARM
+#endif
+#if defined(__mips__)
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_MIPS
+#endif
+#ifdef __m68k__
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_68K
+#endif
+#if defined(__arm64__)
+#define KEXEC_ARCH_NATIVE	KEXEC_ARCH_ARM64
+#endif
+
 #endif /* KEXEC_SYSCALL_H */
diff --git a/kexec/libfdt/libfdt.h b/kexec/libfdt/libfdt.h
index d2c9b5b..fa0f479 100644
--- a/kexec/libfdt/libfdt.h
+++ b/kexec/libfdt/libfdt.h
@@ -1103,4 +1103,28 @@ int fdt_del_node(void *fdt, int nodeoffset);
 
 const char *fdt_strerror(int errval);
 
+#define FDT_ALIGN(x, a)		(((x) + (a) - 1) & ~((a) - 1))
+#define FDT_TAGALIGN(x)		(FDT_ALIGN((x), FDT_TAGSIZE))
+
+/*
+ * if add a new subnode:
+ * see: fdt_add_subnode -> fdt_add_subnode_namelen
+ */
+static inline int fdt_node_len(const char* node_name)
+{
+	return sizeof(struct fdt_node_header) +
+		FDT_TAGALIGN(strlen(node_name) + 1) + FDT_TAGSIZE;
+}
+
+/*
+ * if add a new prop: (assume prop_name not exist in strtab)
+ * see: fdt_setprop -> _fdt_add_property
+ */
+static inline int fdt_prop_len(const char* prop_name, int len)
+{
+	return (strlen(prop_name) + 1) +
+		sizeof(struct fdt_property) +
+		FDT_TAGALIGN(len);
+}
+
 #endif /* _LIBFDT_H */
diff --git a/kexec/libfdt/libfdt_internal.h b/kexec/libfdt/libfdt_internal.h
index 46eb93e..7e6c4c8 100644
--- a/kexec/libfdt/libfdt_internal.h
+++ b/kexec/libfdt/libfdt_internal.h
@@ -52,9 +52,6 @@
  */
 #include <fdt.h>
 
-#define FDT_ALIGN(x, a)		(((x) + (a) - 1) & ~((a) - 1))
-#define FDT_TAGALIGN(x)		(FDT_ALIGN((x), FDT_TAGSIZE))
-
 #define FDT_CHECK_HEADER(fdt) \
 	{ \
 		int err; \
diff --git a/purgatory/Makefile b/purgatory/Makefile
index aa3a788..2bbd921 100644
--- a/purgatory/Makefile
+++ b/purgatory/Makefile
@@ -18,6 +18,7 @@ dist += purgatory/Makefile $(PURGATORY_SRCS)				\
 
 include $(srcdir)/purgatory/arch/alpha/Makefile
 include $(srcdir)/purgatory/arch/arm/Makefile
+include $(srcdir)/purgatory/arch/arm64/Makefile
 include $(srcdir)/purgatory/arch/i386/Makefile
 include $(srcdir)/purgatory/arch/ia64/Makefile
 include $(srcdir)/purgatory/arch/mips/Makefile
diff --git a/purgatory/arch/arm64/Makefile b/purgatory/arch/arm64/Makefile
new file mode 100644
index 0000000..04fef16
--- /dev/null
+++ b/purgatory/arch/arm64/Makefile
@@ -0,0 +1,20 @@
+
+arm64_PURGATORY_EXTRA_CFLAGS = \
+	-mcmodel=large \
+	-fno-stack-protector \
+	-fno-asynchronous-unwind-tables \
+	-fno-exceptions \
+	-Wundef \
+	-Werror-implicit-function-declaration \
+	-Wdeclaration-after-statement \
+	-Werror=implicit-int \
+	-Werror=strict-prototypes
+
+arm64_PURGATORY_SRCS += \
+	purgatory/arch/arm64/entry.S \
+	purgatory/arch/arm64/cache.S \
+	purgatory/arch/arm64/purgatory-arm64.c
+
+dist += \
+	$(arm64_PURGATORY_SRCS) \
+	purgatory/arch/arm64/Makefile
diff --git a/purgatory/arch/arm64/cache.S b/purgatory/arch/arm64/cache.S
new file mode 100644
index 0000000..6bbdeac
--- /dev/null
+++ b/purgatory/arch/arm64/cache.S
@@ -0,0 +1,222 @@
+/*
+ * Cache maintenance
+ * Some of the routine has been copied from Linux Kernel, therefore
+ * copying the license as well.
+ *
+ * Copyright (C) 2001 Deep Blue Solutions Ltd.
+ * Copyright (C) 2012 ARM Ltd.
+ * Copyright (C) 2015 Pratyush Anand <panand@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "cache.h"
+
+/*
+ * dcache_line_size - get the minimum D-cache line size from the CTR register.
+ */
+	.macro	dcache_line_size, reg, tmp
+	mrs	\tmp, ctr_el0			// read CTR
+	ubfm	\tmp, \tmp, #16, #19		// cache line size encoding
+	mov	\reg, #4			// bytes per word
+	lsl	\reg, \reg, \tmp		// actual cache line size
+	.endm
+
+/*
+ *	__inval_cache_range(start, end)
+ *	- start	- start address of region
+ *	- end	- end address of region
+ */
+__inval_cache_range:
+	dcache_line_size x2, x3
+	sub	x3, x2, #1
+	tst	x1, x3				// end cache line aligned?
+	bic	x1, x1, x3
+	b.eq	1f
+	dc	civac, x1			// clean & invalidate D / U line
+1:	tst	x0, x3				// start cache line aligned?
+	bic	x0, x0, x3
+	b.eq	2f
+	dc	civac, x0			// clean & invalidate D / U line
+	b	3f
+2:	dc	ivac, x0			// invalidate D / U line
+3:	add	x0, x0, x2
+	cmp	x0, x1
+	b.lo	2b
+	dsb	sy
+	ret
+/*
+ *	__flush_dcache_range(start, end)
+ *	- start	- start address of region
+ *	- end	- end address of region
+ *
+ */
+__flush_dcache_range:
+	dcache_line_size x2, x3
+	sub	x3, x2, #1
+	bic	x0, x0, x3
+1:	dc	civac, x0			// clean & invalidate D line / unified line
+	add	x0, x0, x2
+	cmp	x0, x1
+	b.lo	1b
+	dsb	sy
+	ret
+
+/*
+ *	enable_dcache(start, end, page_table)
+ *	- start	- start address of ram
+ *	- end	- end address of ram
+ *	- page_table - base of page table
+ */
+.globl enable_dcache
+enable_dcache:
+	stp	x6, x7, [sp,#-16]!
+	stp	x16, x17, [sp,#-16]!
+	stp	x18, x19, [sp,#-16]!
+
+	/* save args */
+	mov x16, x0	/* first segment start */
+	mov x17, x1	/* last segment end */
+	mov x18, x2 	/* page table */
+	mov x19, x30	/* save ret addr */
+
+	/*
+	 * Invalidate the page tables to avoid potential
+	 * dirty cache lines being evicted.
+	 */
+	mov x0, x18
+	add x1, x0, #PAGE_TABLE_SIZE
+	bl __inval_cache_range
+
+	/*
+	 * Clear the page tables.
+	 */
+	mov x0, x18
+	add x1, x0, #PAGE_TABLE_SIZE
+1:	stp	xzr, xzr, [x0], #16
+	stp	xzr, xzr, [x0], #16
+	stp	xzr, xzr, [x0], #16
+	stp	xzr, xzr, [x0], #16
+	cmp	x0, x1
+	b.lo	1b
+
+	/*
+	 * Create the identity mapping.
+	 */
+	ldr	x6, =SECTION_SHIFT
+	ldr	x7, =MM_MMUFLAGS
+	lsr	x0, x16, x6	//first index
+	lsr	x1, x17, x6	//last index
+
+next_sect:
+	lsl	x2, x0, x6	//section
+	orr	x2, x2, x7
+	str	x2, [x18, x0, lsl #3]
+	add	x0, x0, #1
+	cmp	x0, x1
+	b.ls	next_sect
+
+	/*
+	 * Since the page tables have been populated with non-cacheable
+	 * accesses (MMU disabled), invalidate the idmap page
+	 * tables again to remove any speculatively loaded cache lines.
+	 */
+	mov x0, x18
+	add x1, x0, #PAGE_TABLE_SIZE
+	bl __inval_cache_range
+
+	mrs 	x0, CurrentEL
+	cmp	x0, #12	//EL3
+	b.eq	set_el3
+	cmp	x0, #8	//EL2
+	b.eq	set_el2
+	cmp	x0, #4	//EL1
+	b.eq	set_el1
+	b	done_enable
+
+set_el1:
+	msr	ttbr0_el1, x18
+	ldr	x0, =TCR_FLAGS
+	orr	x0, x0, #TCR_EL1_IPS_BITS
+	msr	tcr_el1, x0
+	ldr	x0, =MEMORY_ATTRIBUTES
+	msr	mair_el1, x0
+	mrs	x0, sctlr_el1
+	orr	x0, x0, #CR_M
+	orr	x0, x0, #CR_C
+	msr	sctlr_el1, x0
+	b	done_enable
+set_el2:
+	msr	ttbr0_el2, x18
+	ldr	x0, =TCR_FLAGS
+	orr	x0, x0, #TCR_EL2_IPS_BITS
+	msr	tcr_el2, x0
+	ldr	x0, =MEMORY_ATTRIBUTES
+	msr	mair_el2, x0
+	mrs	x0, sctlr_el2
+	orr	x0, x0, #CR_M
+	orr	x0, x0, #CR_C
+	msr	sctlr_el2, x0
+	b	done_enable
+set_el3:
+	msr	ttbr0_el3, x18
+	ldr	x0, =TCR_FLAGS
+	orr	x0, x0, #TCR_EL3_IPS_BITS
+	msr	tcr_el3, x0
+	ldr	x0, =MEMORY_ATTRIBUTES
+	msr	mair_el3, x0
+	mrs	x0, sctlr_el3
+	orr	x0, x0, #CR_M
+	orr	x0, x0, #CR_C
+	msr	sctlr_el3, x0
+done_enable:
+
+	mov	x30, x19
+	ldp	x18, x19, [sp],#16
+	ldp	x16, x17, [sp],#16
+	ldp	x6, x7, [sp],#16
+
+	ret
+
+.globl disable_dcache
+disable_dcache:
+	stp	x5, x30, [sp,#-16]!
+	mrs 	x5, CurrentEL
+	cmp	x5, #12	//EL3
+	b.eq	disable_el3
+	cmp	x5, #8	//EL2
+	b.eq	disable_el2
+	cmp	x5, #4	//EL1
+	b.eq	disable_el1
+	b	done_disable
+disable_el3:
+	mrs	x5, sctlr_el3
+	bic	x5, x2, #CR_M
+	bic	x5, x2, #CR_C
+	msr	sctlr_el3, x5
+	b	done_disable
+disable_el2:
+	mrs	x5, sctlr_el2
+	bic	x5, x2, #CR_M
+	bic	x5, x2, #CR_C
+	msr	sctlr_el2, x5
+	b	done_disable
+disable_el1:
+	mrs	x5, sctlr_el1
+	bic	x5, x2, #CR_M
+	bic	x5, x2, #CR_C
+	msr	sctlr_el1, x5
+done_disable:
+	bl __flush_dcache_range
+	ldp	x5, x30, [sp],#16
+	ret
diff --git a/purgatory/arch/arm64/cache.h b/purgatory/arch/arm64/cache.h
new file mode 100644
index 0000000..3ca1d7f
--- /dev/null
+++ b/purgatory/arch/arm64/cache.h
@@ -0,0 +1,42 @@
+#ifndef	__CACHE_H__
+#define __CACHE_H__
+
+#define VA_BITS			42
+#define SECTION_SHIFT		29
+#define PAGE_TABLE_SIZE		(1 << (VA_BITS - SECTION_SHIFT + 3))
+
+#define TCR_TG0_64K 		(1 << 14)
+#define TCR_SHARED_NON		(0 << 12)
+#define TCR_ORGN_WBWA		(1 << 10)
+#define TCR_IRGN_WBWA		(1 << 8)
+#define TCR_T0SZ(x)		((64 - (x)) << 0)
+#define TCR_EL1_IPS_BITS	(3 << 32) /* 42 bits physical address */
+#define TCR_EL2_IPS_BITS	(3 << 16) /* 42 bits physical address */
+#define TCR_EL3_IPS_BITS	(3 << 16) /* 42 bits physical address */
+
+#define TCR_FLAGS (TCR_TG0_64K | TCR_SHARED_NON | TCR_ORGN_WBWA | \
+		TCR_IRGN_WBWA | TCR_T0SZ(VA_BITS))
+
+#define MT_DEVICE_NGNRNE	0
+#define MT_DEVICE_NGNRE		1
+#define MT_DEVICE_GRE		2
+#define MT_NORMAL_NC		3
+#define MT_NORMAL		4
+
+#define MEMORY_ATTRIBUTES	((0x00 << (MT_DEVICE_NGNRNE*8)) | \
+				(0x04 << (MT_DEVICE_NGNRE*8)) | \
+				(0x0c << (MT_DEVICE_GRE*8)) | \
+				(0x44 << (MT_NORMAL_NC*8)) | \
+				(0xff << (MT_NORMAL*8)))
+
+#define CR_M			(1 << 0)	/* MMU enable */
+#define CR_C			(1 << 2)	/* Dcache enable */
+
+
+#define PMD_TYPE_SECT		(1 << 0)
+#define PMD_SECT_AF		(1 << 10)
+#define PMD_ATTRINDX(t)		((t) << 2)
+#define PMD_FLAGS	(PMD_TYPE_SECT | PMD_SECT_AF)
+#define MM_MMUFLAGS	PMD_ATTRINDX(MT_NORMAL) | PMD_FLAGS
+
+#endif
diff --git a/purgatory/arch/arm64/entry.S b/purgatory/arch/arm64/entry.S
new file mode 100644
index 0000000..0713ccd
--- /dev/null
+++ b/purgatory/arch/arm64/entry.S
@@ -0,0 +1,64 @@
+/*
+ * ARM64 purgatory.
+ */
+
+.macro	debug_brk
+	mov	x0, #0x18;		/* angel_SWIreason_ReportException */
+	mov	x1, #0x20000;
+	add	x1, x1, #0x20;		/* ADP_Stopped_BreakPoint */
+	hlt	#0xf000			/* A64 semihosting */
+.endm
+
+.macro	size, sym:req
+	.size \sym, . - \sym
+.endm
+
+.text
+
+.globl purgatory_start
+purgatory_start:
+
+	adr	x19, .Lstack
+	mov	sp, x19
+
+	bl	purgatory
+
+1:	debug_brk
+	b	1b
+
+size purgatory_start 
+
+.align 4
+	.rept	256
+	.quad	0
+	.endr
+.Lstack:
+
+.data
+
+.align 3
+
+.globl arm64_sink
+arm64_sink:
+	.quad	0
+size arm64_sink
+
+.globl arm64_kernel_entry
+arm64_kernel_entry:
+	.quad	0
+size arm64_kernel_entry
+
+.globl arm64_dtb_addr
+arm64_dtb_addr:
+	.quad	0
+size arm64_dtb_addr
+
+.globl arm64_ram_start
+arm64_ram_start:
+	.quad	0
+size arm64_ram_start
+
+.globl arm64_ram_end
+arm64_ram_end:
+	.quad	0
+size arm64_ram_end
diff --git a/purgatory/arch/arm64/purgatory-arm64.c b/purgatory/arch/arm64/purgatory-arm64.c
new file mode 100644
index 0000000..e045039
--- /dev/null
+++ b/purgatory/arch/arm64/purgatory-arm64.c
@@ -0,0 +1,69 @@
+/*
+ * ARM64 purgatory.
+ */
+
+#include "cache.h"
+#include <stdint.h>
+#include <purgatory.h>
+
+/* Symbols set by kexec. */
+
+extern uint32_t *arm64_sink;
+extern void (*arm64_kernel_entry)(uint64_t);
+extern uint64_t arm64_dtb_addr;
+extern uint64_t arm64_ram_start;
+extern uint64_t arm64_ram_end;
+
+static void wait_for_xmit_complete(void)
+{
+	volatile uint32_t status;
+	volatile uint32_t *status_reg;
+
+	/*
+	 * Since most of the UART with ARM platform has LSR register at
+	 * offset 0x14 and should have value as 0x60 for TX empty, so we
+	 * have hardcoded these values. Can modify in future if need
+	 * arises.
+	 */
+	status_reg = (volatile uint32_t *)((uint64_t)arm64_sink + 0x14);
+	while (1) {
+		status = *status_reg;
+		if ((status & 0x60) == 0x60)
+			break;
+	}
+}
+
+void putchar(int ch)
+{
+	if (!arm64_sink)
+		return;
+
+	wait_for_xmit_complete();
+	*arm64_sink = ch;
+
+	if (ch == '\n') {
+		wait_for_xmit_complete();
+		*arm64_sink = '\r';
+	}
+}
+
+uint64_t page_table[PAGE_TABLE_SIZE / sizeof(uint64_t)] __attribute__ ((aligned (PAGE_TABLE_SIZE))) = { };
+extern void enable_dcache(uint64_t , uint64_t , uint64_t *);
+extern void disable_dcache(uint64_t , uint64_t);
+
+void setup_arch(void)
+{
+	printf("purgatory: kernel_entry: %lx\n",
+		(unsigned long)arm64_kernel_entry);
+	printf("purgatory: dtb:          %lx\n", arm64_dtb_addr);
+	printf("purgatory: RAM start: %lx\n", arm64_ram_start);
+	printf("purgatory: RAM end: %lx\n", arm64_ram_end);
+
+	enable_dcache(arm64_ram_start, arm64_ram_end, page_table);
+}
+
+void post_verification_setup_arch(void)
+{
+	disable_dcache(arm64_ram_start, arm64_ram_end);
+	arm64_kernel_entry(arm64_dtb_addr);
+}
